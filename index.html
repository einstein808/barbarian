<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>PIXIJS Survivors</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
    }
    canvas {
        display: block;
        margin: 0 auto;
    }
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>

<script>
const GAME_WIDTH = 1280;
const GAME_HEIGHT = 720;

PIXI.settings.ALPHA_MODE = PIXI.ALPHA_MODES.UNPACK;

const app = new PIXI.Application({
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    backgroundColor: 0x000000,
});
document.body.appendChild(app.view);

const bgSound = new Audio("audio/background.mp3");
bgSound.loop = true;
bgSound.volume = 0.4;

const hitSound = new Audio("audio/hit.mp3");
hitSound.volume = 0.8;

const deathSound = new Audio("audio/death.mp3");
deathSound.volume = 0.8;

function setAllVolumes(vol) {
    bgSound.volume = vol;
    hitSound.volume = vol;
    deathSound.volume = vol;
}

function tryPlayBackground() {
    bgSound.play().catch(() => {
        window.addEventListener("click", () => {
            bgSound.play();
        }, { once: true });
    });
}

const STATE = {
    MENU: "menu",
    VOLUME: "volume",
    PLAYING: "playing",
    GAMEOVER: "gameover",
};
let currentState = STATE.MENU;

let player, enemies = [], obstacles = [], projectiles = [];
let kills = 0, difficulty = 0, spawnDelay = 100, nextSpawn = 0;
let elapsedTime = 0, score = 0;
let camX = 0, camY = 0;

const menuContainer = new PIXI.Container();
const volumeContainer = new PIXI.Container();
const gameContainer = new PIXI.Container();
const hudContainer = new PIXI.Container();
const gameOverContainer = new PIXI.Container();

app.stage.addChild(menuContainer);
app.stage.addChild(volumeContainer);
app.stage.addChild(gameContainer);
app.stage.addChild(hudContainer);
app.stage.addChild(gameOverContainer);

menuContainer.visible = true;
volumeContainer.visible = false;
gameContainer.visible = false;
hudContainer.visible = false;
gameOverContainer.visible = false;

const style = new PIXI.TextStyle({
    fill: "#ffffff",
    fontSize: 24,
    fontWeight: "bold",
    stroke: '#000000',
    strokeThickness: 3,
});

const menuTitle = new PIXI.Text("üßõ Vampire Survivors PIXI üßõ", {
    fill: "#ff4444",
    fontSize: 48,
    fontWeight: "bold",
    stroke: '#000000',
    strokeThickness: 5,
});
menuTitle.anchor.set(0.5);
menuTitle.x = GAME_WIDTH / 2;
menuTitle.y = GAME_HEIGHT / 3;
menuContainer.addChild(menuTitle);

function createButton(text, y, onClick) {
    const btn = new PIXI.Container();
    const bg = new PIXI.Graphics();
    bg.beginFill(0x880000);
    bg.drawRoundedRect(0, 0, 300, 60, 15);
    bg.endFill();

    const label = new PIXI.Text(text, {
        fill: "#fff",
        fontSize: 28,
        fontWeight: "bold",
    });
    label.anchor.set(0.5);
    label.x = 150;
    label.y = 30;

    btn.addChild(bg);
    btn.addChild(label);

    btn.x = (GAME_WIDTH - 300) / 2;
    btn.y = y;

    btn.interactive = true;
    btn.buttonMode = true;
    btn.on('pointerdown', onClick);

    return btn;
}

const playBtn = createButton("‚ñ∂ Jogar", GAME_HEIGHT / 2, () => {
    resetGame();
    switchToState(STATE.PLAYING);
});
menuContainer.addChild(playBtn);

const volumeBtn = createButton("üîä Volumes", GAME_HEIGHT / 2 + 80, () => {
    switchToState(STATE.VOLUME);
});
menuContainer.addChild(volumeBtn);


const volumeTitle = new PIXI.Text("Controle de Volume", {
    fill: "#44aa44",
    fontSize: 40,
    fontWeight: "bold",
    stroke: '#000000',
    strokeThickness: 4,
});
volumeTitle.anchor.set(0.5);
volumeTitle.x = GAME_WIDTH / 2;
volumeTitle.y = 100;
volumeContainer.addChild(volumeTitle);

const volumeDisplay = new PIXI.Text("", style);
volumeDisplay.anchor.set(0.5);
volumeDisplay.x = GAME_WIDTH / 2;
volumeDisplay.y = 180;
volumeContainer.addChild(volumeDisplay);

let volumeLevel = 0.4;

function updateVolumeText() {
    volumeDisplay.text = `Volume: ${Math.round(volumeLevel * 100)}%`;
}
updateVolumeText();

const volDownBtn = createButton("üîâ Diminuir", GAME_HEIGHT / 2 - 30, () => {
    volumeLevel = Math.max(0, volumeLevel - 0.1);
    setAllVolumes(volumeLevel);
    updateVolumeText();
});
volumeContainer.addChild(volDownBtn);

const volUpBtn = createButton("üîä Aumentar", GAME_HEIGHT / 2 + 50, () => {
    volumeLevel = Math.min(1, volumeLevel + 0.1);
    setAllVolumes(volumeLevel);
    updateVolumeText();
});
volumeContainer.addChild(volUpBtn);

const volBackBtn = createButton("‚¨Ö Voltar", GAME_HEIGHT / 2 + 130, () => {
    switchToState(STATE.MENU);
});
volumeContainer.addChild(volBackBtn);


const hpText = new PIXI.Text("HP: 100", style);
hpText.position.set(20, 20);
hudContainer.addChild(hpText);

const timeText = new PIXI.Text("Tempo: 0s", style);
timeText.position.set(GAME_WIDTH / 2 - 50, 20);
hudContainer.addChild(timeText);

const scoreText = new PIXI.Text("Score: 0", style);
scoreText.position.set(GAME_WIDTH - 180, 20);
hudContainer.addChild(scoreText);


const gameOverBg = new PIXI.Graphics();
gameOverBg.beginFill(0x550000, 0.85);
gameOverBg.drawRoundedRect(0, 0, GAME_WIDTH, GAME_HEIGHT, 20);
gameOverBg.endFill();
gameOverContainer.addChild(gameOverBg);

const gameOverText = new PIXI.Text("üíÄ GAME OVER üíÄ", {
    fill: "#ff5555",
    fontSize: 72,
    fontWeight: "bold",
    stroke: "#000000",
    strokeThickness: 8,
});
gameOverText.anchor.set(0.5);
gameOverText.x = GAME_WIDTH / 2;
gameOverText.y = GAME_HEIGHT / 3;
gameOverContainer.addChild(gameOverText);

const finalScoreText = new PIXI.Text("", {
    fill: "#ffffff",
    fontSize: 32,
    fontWeight: "bold",
    stroke: "#000000",
    strokeThickness: 5,
});
finalScoreText.anchor.set(0.5);
finalScoreText.x = GAME_WIDTH / 2;
finalScoreText.y = GAME_HEIGHT / 2.2;
gameOverContainer.addChild(finalScoreText);

const replayBtn = createButton("üîÑ Jogar Novamente", GAME_HEIGHT / 2 + 100, () => {
    resetGame();
    switchToState(STATE.PLAYING);
});
gameOverContainer.addChild(replayBtn);


PIXI.Assets.load([
    "sprites/background.png",
    "sprites/inimigos.png",
    "sprites/obstaculo.png",
    "sprites/projetil.png",
    "sprites/protag.png"
]).then(initGame);

let gameData = null;


function switchToState(newState) {
    currentState = newState;

    menuContainer.visible = false;
    volumeContainer.visible = false;
    gameContainer.visible = false;
    hudContainer.visible = false;
    gameOverContainer.visible = false;

    if (newState === STATE.MENU) {
        menuContainer.visible = true;
        stopGameSounds();
    } else if (newState === STATE.VOLUME) {
        volumeContainer.visible = true;
    } else if (newState === STATE.PLAYING) {
        gameContainer.visible = true;
        hudContainer.visible = true;
        tryPlayBackground();
    } else if (newState === STATE.GAMEOVER) {
        gameOverContainer.visible = true;
        finalScoreText.text = `Sua pontua√ß√£o final foi:\n${Math.floor(score)}`;
        stopGameSounds();
        deathSound.currentTime = 0;
        deathSound.play();
    }
}

function stopGameSounds() {
    bgSound.pause();
    bgSound.currentTime = 0;
    hitSound.pause();
    hitSound.currentTime = 0;
    deathSound.pause();
    deathSound.currentTime = 0;
}

function initGame() {
    const texBackground = PIXI.Texture.from("sprites/background.png");
    const bg = new PIXI.TilingSprite(texBackground, GAME_WIDTH, GAME_HEIGHT);
    bg.scale.set(1.0);
    gameContainer.addChild(bg);

    const texProtag = PIXI.Texture.from("sprites/protag.png");
    player = new PIXI.Sprite(texProtag);
    player.anchor.set(0.5);
    player.scale.set(0.45);
    player.speed = 4;
    player.worldX = 0;
    player.worldY = 0;
    player.hp = 100;
    gameContainer.addChild(player);

    const texEnemies = PIXI.Texture.from("sprites/inimigos.png");
    const texObstacle = PIXI.Texture.from("sprites/obstaculo.png");
    const texProjectile = PIXI.Texture.from("sprites/projetil.png");

    enemies = [];
    obstacles = [];
    projectiles = [];

    function createEnemy() {
        const type = Math.floor(Math.random() * 4);
        const ENEMY_FRAME_W = texEnemies.width / 4;
        const t = new PIXI.Texture(
            texEnemies.baseTexture,
            new PIXI.Rectangle(type * ENEMY_FRAME_W, 0, ENEMY_FRAME_W, texEnemies.height)
        );
        const e = new PIXI.Sprite(t);
        e.anchor.set(0.5);
        e.scale.set(0.55);

        e.worldX = player.worldX + (600 + Math.random() * 300) * (Math.random() < 0.5 ? -1 : 1);
        e.worldY = player.worldY + (600 + Math.random() * 300) * (Math.random() < 0.5 ? -1 : 1);

        e.speed = 1.2 + difficulty * 0.25;
        e.hp = 10 + difficulty * 4;

        enemies.push(e);
        gameContainer.addChild(e);
    }

    function spawnObstacle() {
        const o = new PIXI.Sprite(texObstacle);
        o.anchor.set(0.5);
        o.scale.set(0.7);
        o.size = 64;

        o.worldX = player.worldX + (300 + Math.random() * 700) * (Math.random() < 0.5 ? -1 : 1);
        o.worldY = player.worldY + (300 + Math.random() * 700) * (Math.random() < 0.5 ? -1 : 1);

        obstacles.push(o);
        gameContainer.addChild(o);
    }

    for (let i = 0; i < 8; i++) spawnObstacle();

    function getClosestEnemy() {
        let best = null;
        let bd = Infinity;
        for (const e of enemies) {
            const d = Math.hypot(e.worldX - player.worldX, e.worldY - player.worldY);
            if (d < bd) { best = e; bd = d; }
        }
        return best;
    }

    function fireProjectile() {
        if (currentState !== STATE.PLAYING) return;

        const target = getClosestEnemy();

        let ang, vx, vy;

        if (!target) {
            ang = Math.random() * Math.PI * 2;
            vx = Math.cos(ang) * 8;
            vy = Math.sin(ang) * 8;
        } else {
            const dx = target.worldX - player.worldX;
            const dy = target.worldY - player.worldY;
            ang = Math.atan2(dy, dx);

            const d = Math.hypot(dx, dy);
            vx = dx / d * 8;
            vy = dy / d * 8;
        }

        const p = new PIXI.Sprite(texProjectile);
        p.anchor.set(0.5);
        p.scale.set(0.28);
        p.rotation = ang;

        p.worldX = player.worldX;
        p.worldY = player.worldY;

        p.vx = vx;
        p.vy = vy;
        p.life = 90;

        projectiles.push(p);
        gameContainer.addChild(p);
    }

    gameData = {
        createEnemy,
        spawnObstacle,
        fireProjectile,
    };

    setInterval(() => {
        if (currentState === STATE.PLAYING) gameData.fireProjectile();
    }, 300);
}

function resetGame() {
    kills = 0;
    difficulty = 0;
    spawnDelay = 100;
    nextSpawn = 0;
    elapsedTime = 0;
    score = 0;
    camX = 0;
    camY = 0;

    player.hp = 100;
    player.worldX = 0;
    player.worldY = 0;

    for (const e of enemies) gameContainer.removeChild(e);
    for (const o of obstacles) gameContainer.removeChild(o);
    for (const p of projectiles) gameContainer.removeChild(p);

    enemies.length = 0;
    obstacles.length = 0;
    projectiles.length = 0;

    for (let i = 0; i < 8; i++) gameData.spawnObstacle();
}

function updateCamera() {
    camX = player.worldX - GAME_WIDTH / 2;
    camY = player.worldY - GAME_HEIGHT / 2;

    if(gameContainer.children.length > 0 && gameContainer.children[0] instanceof PIXI.TilingSprite){
        gameContainer.children[0].tilePosition.x = -camX * 0.25;
        gameContainer.children[0].tilePosition.y = -camY * 0.25;
    }
}

const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

app.ticker.add(() => {
    if (currentState !== STATE.PLAYING) return;

    elapsedTime += app.ticker.elapsedMS / 1000;

    let dx = 0, dy = 0;
    if (keys["w"] || keys["arrowup"]) dy -= 1;
    if (keys["s"] || keys["arrowdown"]) dy += 1;
    if (keys["a"] || keys["arrowleft"]) dx -= 1;
    if (keys["d"] || keys["arrowright"]) dx += 1;

    const moving = dx !== 0 || dy !== 0;

    if (moving) {
        const l = Math.hypot(dx, dy);
        dx /= l; dy /= l;
        player.worldX += dx * player.speed;
        player.worldY += dy * player.speed;
    }

    for (const o of obstacles) {
        const hw = o.size / 2;
        if (Math.abs(player.worldX - o.worldX) < hw + 20 &&
            Math.abs(player.worldY - o.worldY) < hw + 20) {
            player.worldX -= dx * player.speed;
            player.worldY -= dy * player.speed;
        }
    }

    nextSpawn--;
    if (nextSpawn <= 0) {
        nextSpawn = spawnDelay;
        gameData.createEnemy();
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        const ax = player.worldX - e.worldX;
        const ay = player.worldY - e.worldY;
        const d = Math.hypot(ax, ay);

        e.worldX += (ax / d) * e.speed;
        e.worldY += (ay / d) * e.speed;

        for (const o of obstacles) {
            const hw = o.size / 2;
            const cx = Math.max(o.worldX - hw, Math.min(e.worldX, o.worldX + hw));
            const cy = Math.max(o.worldY - hw, Math.min(e.worldY, o.worldY + hw));
            if ((e.worldX - cx) ** 2 + (e.worldY - cy) ** 2 < 20 * 20) {
                e.worldX -= (ax / d) * e.speed;
                e.worldY -= (ay / d) * e.speed;
            }
        }

        if (d < 28) player.hp -= 0.1;

        if (e.hp <= 0) {
            gameContainer.removeChild(e);
            enemies.splice(i, 1);
            kills++;

            score += 100 + elapsedTime * 10;

            hitSound.currentTime = 0;
            hitSound.play();

            const dif = Math.floor(kills / 15);
            if (dif > difficulty) {
                difficulty = dif;
                spawnDelay = Math.max(20, 100 - difficulty * 8);
            }
        }
    }

    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];

        p.worldX += p.vx;
        p.worldY += p.vy;
        p.life--;

        let destroy = false;

        for (const o of obstacles) {
            const hw = o.size / 2;
            const cx = Math.max(o.worldX - hw, Math.min(p.worldX, o.worldX + hw));
            const cy = Math.max(o.worldY - hw, Math.min(p.worldY, o.worldY + hw));
            if ((p.worldX - cx) ** 2 + (p.worldY - cy) ** 2 < 10 * 10) {
                destroy = true;
                break;
            }
        }

        if (!destroy) {
            for (const e of enemies) {
                if (Math.hypot(p.worldX - e.worldX, p.worldY - e.worldY) < 28) {
                    e.hp -= 10;
                    destroy = true;
                    break;
                }
            }
        }

        if (destroy || p.life <= 0) {
            gameContainer.removeChild(p);
            projectiles.splice(i, 1);
        }
    }

    updateCamera();

    player.x = player.worldX - camX;
    player.y = player.worldY - camY;

    for (const e of enemies) {
        e.x = e.worldX - camX;
        e.y = e.worldY - camY;
    }

    for (const o of obstacles) {
        o.x = o.worldX - camX;
        o.y = o.worldY - camY;
    }

    for (const p of projectiles) {
        p.x = p.worldX - camX;
        p.y = p.worldY - camY;
    }

    hpText.text = `HP: ${Math.max(0, Math.floor(player.hp))}`;
    timeText.text = `Tempo: ${Math.floor(elapsedTime)}s`;
    scoreText.text = `Score: ${Math.floor(score)}`;

    if (player.hp <= 0) {
        switchToState(STATE.GAMEOVER);
    }
});
</script>
</body>
</html>
